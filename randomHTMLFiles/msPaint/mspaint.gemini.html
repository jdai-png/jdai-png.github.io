<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Paint</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: #333;
            color: #fff;
        }

        #toolbar {
            display: flex;
            flex-direction: column;
            padding: 10px;
            background-color: #282c34;
            border-right: 2px solid #444;
            width: 200px;
            overflow-y: auto;
        }

        #toolbar h3 {
            margin-top: 15px;
            margin-bottom: 5px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            font-size: 1em;
        }

        #toolbar button, .tool-group button {
            width: 100%;
            padding: 10px 5px;
            margin-bottom: 5px;
            border: 1px solid #555;
            background-color: #404552;
            color: #fff;
            cursor: pointer;
            text-align: left;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        #toolbar button.active, .tool-group button.active {
            background-color: #61afef;
            color: #282c34;
            font-weight: bold;
        }

        #toolbar button:hover, .tool-group button:hover {
            background-color: #528baf;
        }
        
        #toolbar label {
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        #toolbar input[type="color"], #toolbar input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        
        .tool-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .tool-group button {
            flex-basis: calc(50% - 2.5px);
            text-align: center;
        }

        #canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background-image:
                linear-gradient(45deg, #444 25%, transparent 25%),
                linear-gradient(-45deg, #444 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #444 75%),
                linear-gradient(-45deg, transparent 75%, #444 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas {
            border: 2px solid #61afef;
            background-color: #fff;
            cursor: crosshair;
        }
        
        #status-bar {
            position: fixed;
            bottom: 0;
            left: 220px;
            right: 0;
            background: #282c34;
            padding: 5px 10px;
            font-size: 0.8em;
            color: #ccc;
        }

    </style>
</head>
<body>

    <div id="toolbar">
        <h3>File</h3>
        <button id="exportBtn">Export as PNG</button>
        <p style="font-size:0.8em; color:#999;">Standard Ctrl+C / Ctrl+V supported for copy/paste.</p>
        
        <h3>Tools</h3>
        <div class="tool-group">
            <button class="tool active" data-tool="select">Select</button>
            <button class="tool" data-tool="freestyle">Freestyle</button>
            <button class="tool" data-tool="line">Line</button>
            <button class="tool" data-tool="rectangle">Rectangle</button>
            <button class="tool" data-tool="circle">Circle</button>
            <button class="tool" data-tool="polygon">Polygon</button>
            <button class="tool" data-tool="arc">Arc</button>
            <button class="tool" data-tool="eraser">Eraser</button>
        </div>

        <h3>Mapping Tools</h3>
         <div class="tool-group">
            <button class="special-tool" data-tool="road">Road</button>
            <button class="special-tool" data-tool="piping">Piping</button>
            <button class="special-tool" data-tool="electrical">Electrical</button>
            <button class="special-tool" data-tool="plumbing">Plumbing</button>
        </div>

        <h3>Properties</h3>
        <label for="strokeColor">Stroke Color</label>
        <input type="color" id="strokeColor" value="#000000">

        <label for="fillColor">Fill Color</label>
        <input type="color" id="fillColor" value="#FFFFFF">

        <label for="lineWidth">Line Width</label>
        <input type="range" id="lineWidth" min="1" max="50" value="5">
        
        <label for="eraserSize">Eraser Size</label>
        <input type="range" id="eraserSize" min="2" max="100" value="20">
    </div>

    <div id="canvas-container">
        <canvas id="paint-canvas"></canvas>
    </div>
    
    <div id="status-bar">
      Zoom: 100% | X: 0, Y: 0 | Tool: Select | Tip: Drag & Drop PNGs onto canvas.
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('paint-canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        // Toolbar elements
        const strokeColorInput = document.getElementById('strokeColor');
        const fillColorInput = document.getElementById('fillColor');
        const lineWidthInput = document.getElementById('lineWidth');
        const eraserSizeInput = document.getElementById('eraserSize');
        const exportBtn = document.getElementById('exportBtn');
        const statusBar = document.getElementById('status-bar');

        // Application state
        let state = {
            currentTool: 'select',
            isDrawing: false,
            isPanning: false,
            strokeColor: '#000000',
            fillColor: '#FFFFFF',
            lineWidth: 5,
            eraserSize: 20,
            zoom: 1,
            panOffset: { x: 0, y: 0 },
            startPanPoint: { x: 0, y: 0 },
            startDrawPoint: { x: 0, y: 0 },
            // For multi-step tools like Polygon and Arc
            tempPoints: [],
            // For assets like dropped images
            assets: [],
            selectedAsset: null,
            isTransforming: false,
            transformHandle: null,
            // For selection tool
            selectionRect: null
        };
        
        let canvasSnapshot; // Used for previewing shapes

        function resizeCanvas() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            state.panOffset.x = canvas.width / 2;
            state.panOffset.y = canvas.height / 2;
            redraw();
        }

        // --- Core Drawing & Transformation ---

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function screenToWorld(point) {
            return {
                x: (point.x - state.panOffset.x) / state.zoom,
                y: (point.y - state.panOffset.y) / state.zoom,
            };
        }

        function worldToScreen(point) {
            return {
                x: point.x * state.zoom + state.panOffset.x,
                y: point.y * state.zoom + state.panOffset.y
            };
        }
        
        function applyTransform() {
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset
            ctx.translate(state.panOffset.x, state.panOffset.y);
            ctx.scale(state.zoom, state.zoom);
        }

        function redraw() {
            // Clear screen
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            applyTransform();

            // Draw all assets
            state.assets.forEach(asset => {
                ctx.drawImage(asset.img, asset.x, asset.y, asset.width, asset.height);
            });

            // Draw selection box if an asset is selected
            if (state.selectedAsset && state.currentTool === 'select') {
                drawSelectionHandles(state.selectedAsset);
            }

            // Draw selection marquee
            if (state.selectionRect && state.currentTool === 'select' && !state.selectedAsset) {
                ctx.save();
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 1 / state.zoom;
                ctx.setLineDash([5 / state.zoom, 5 / state.zoom]);
                const {x, y, width, height} = state.selectionRect;
                ctx.strokeRect(x, y, width, height);
                ctx.restore();
            }
        }

        // --- Event Handlers ---

        function onMouseDown(e) {
            state.isDrawing = true;
            const mousePos = getMousePos(e);
            state.startDrawPoint = screenToWorld(mousePos);
            
            // Middle mouse button for panning
            if (e.button === 1) {
                state.isPanning = true;
                state.startPanPoint = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
                return;
            }

            canvasSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);

            ctx.beginPath();
            ctx.moveTo(state.startDrawPoint.x, state.startDrawPoint.y);

            switch(state.currentTool) {
                case 'select':
                    handleSelectMouseDown(mousePos);
                    break;
                case 'freestyle':
                case 'eraser':
                    ctx.lineWidth = (state.currentTool === 'eraser' ? state.eraserSize : state.lineWidth) / state.zoom;
                    ctx.strokeStyle = state.currentTool === 'eraser' ? 'white' : state.strokeColor;
                    ctx.globalCompositeOperation = state.currentTool === 'eraser' ? 'destination-out' : 'source-over';
                    break;
                case 'polygon':
                    handlePolygonClick();
                    break;
                case 'arc':
                    handleArcClick();
                    break;
            }
        }

        function onMouseMove(e) {
            const mousePos = getMousePos(e);
            const worldPos = screenToWorld(mousePos);
            updateStatusBar(worldPos);

            if (state.isPanning) {
                const dx = e.clientX - state.startPanPoint.x;
                const dy = e.clientY - state.startPanPoint.y;
                state.panOffset.x += dx;
                state.panOffset.y += dy;
                state.startPanPoint = { x: e.clientX, y: e.clientY };
                redraw();
                return;
            }

            if (!state.isDrawing) {
                 if (state.currentTool === 'select' && state.selectedAsset) {
                    const handle = getHandleUnderCursor(mousePos, state.selectedAsset);
                    canvas.style.cursor = handle ? handle.cursor : 'move';
                }
                return;
            }

            // Restore canvas for preview
            if (['line', 'rectangle', 'circle'].includes(state.currentTool)) {
                ctx.putImageData(canvasSnapshot, 0, 0);
            }
            
            // Handle active transforming (moving/resizing)
            if (state.isTransforming && state.selectedAsset) {
                handleAssetTransform(worldPos);
                redraw();
                return;
            }

            applyTransform(); // Apply after snapshot restore if any

            switch(state.currentTool) {
                case 'select':
                    if (state.isDrawing && !state.selectedAsset) { // Drawing marquee
                       drawMarqueePreview(worldPos);
                    }
                    break;
                case 'freestyle':
                case 'eraser':
                    ctx.lineTo(worldPos.x, worldPos.y);
                    ctx.stroke();
                    break;
                case 'line':
                    drawPreview(() => drawLine(state.startDrawPoint, worldPos));
                    break;
                case 'rectangle':
                    drawPreview(() => drawRectangle(state.startDrawPoint, worldPos));
                    break;
                case 'circle':
                    drawPreview(() => drawCircle(state.startDrawPoint, worldPos));
                    break;
            }
        }
        
        function onMouseUp(e) {
            if (state.isPanning) {
                state.isPanning = false;
                canvas.style.cursor = 'default';
                setToolCursor();
            }
            
            if (!state.isDrawing) return;
            state.isDrawing = false;
            state.isTransforming = false;
            state.transformHandle = null;

            const mousePos = getMousePos(e);
            const worldPos = screenToWorld(mousePos);

            applyTransform();
            let asset = { img: new Image(), x: 0, y: 0, width: 0, height: 0 };
            let tempCanvas, tempCtx;
            
            // Create a temporary canvas matching the drawn shape
            const createShapeCanvas = (rect) => {
                tempCanvas = document.createElement('canvas');
                tempCanvas.width = rect.width * state.zoom;
                tempCanvas.height = rect.height * state.zoom;
                tempCtx = tempCanvas.getContext('2d');
                tempCtx.scale(state.zoom, state.zoom);
                tempCtx.translate(-rect.x, -rect.y);
                asset.x = rect.x;
                asset.y = rect.y;
                asset.width = rect.width;
                asset.height = rect.height;
            };

            switch(state.currentTool) {
                case 'select':
                     if (state.selectionRect && !state.selectedAsset) {
                        // Finalize marquee selection
                        redraw(); // Just to show final marquee
                     } else {
                        state.selectedAsset = null;
                        redraw();
                     }
                    break;
                case 'line':
                    createShapeCanvas(getLineBoundingBox(state.startDrawPoint, worldPos));
                    drawLine(state.startDrawPoint, worldPos, tempCtx);
                    break;
                case 'rectangle':
                    createShapeCanvas(getRect(state.startDrawPoint, worldPos));
                    drawRectangle(state.startDrawPoint, worldPos, tempCtx);
                    break;
                case 'circle':
                    createShapeCanvas(getRect(state.startDrawPoint, worldPos));
                    drawCircle(state.startDrawPoint, worldPos, tempCtx);
                    break;
                case 'polygon':
                case 'arc':
                    return; // These tools have different finalization logic
                case 'freestyle':
                case 'eraser':
                    ctx.closePath();
                    // Capture freestyle/erased drawing as an asset
                    const bounds = getFreestyleBounds(ctx); // This would be complex, let's simplify
                    break; // Freestyle is drawn directly for now, not as an asset.
            }
            
            // Convert drawn shape on temp canvas to an asset
            if (tempCanvas && ['line', 'rectangle', 'circle'].includes(state.currentTool)) {
                asset.img.src = tempCanvas.toDataURL();
                asset.img.onload = () => {
                    state.assets.push(asset);
                    redraw();
                };
            }
            
            // Reset for next drawing
            ctx.globalCompositeOperation = 'source-over';
        }

        function onWheel(e) {
            e.preventDefault();
            const mousePos = getMousePos(e);

            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(10, state.zoom * scaleFactor));
            
            const worldPos = screenToWorld(mousePos);
            state.panOffset.x = mousePos.x - worldPos.x * newZoom;
            state.panOffset.y = mousePos.y - worldPos.y * newZoom;
            state.zoom = newZoom;

            updateStatusBar();
            redraw();
        }

        // --- Tool Logic ---
        function setTool(toolName) {
            state.currentTool = toolName;
            state.tempPoints = []; // Reset for polygon/arc
            state.selectionRect = null;
            if (toolName !== 'select') state.selectedAsset = null;
            
            document.querySelectorAll('.tool, .special-tool').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-tool="${toolName}"]`).classList.add('active');
            
            setToolCursor();
            updateStatusBar();
            redraw();
        }
        
        function setToolCursor() {
            if (state.currentTool === 'select') canvas.style.cursor = 'default';
            else if (state.isPanning) canvas.style.cursor = 'grabbing';
            else canvas.style.cursor = 'crosshair';
        }

        function drawPreview(drawFunc) {
            applyTransform();
            drawFunc();
        }

        function finalizeDrawing(drawFunc) {
            applyTransform();
            drawFunc(ctx);
        }

        // Line
        function drawLine(p1, p2, targetCtx = ctx) {
            targetCtx.lineWidth = state.lineWidth / (targetCtx === ctx ? state.zoom : 1);
            targetCtx.strokeStyle = state.strokeColor;
            targetCtx.lineCap = 'round';
            targetCtx.beginPath();
            targetCtx.moveTo(p1.x, p1.y);
            targetCtx.lineTo(p2.x, p2.y);
            targetCtx.stroke();
        }
        
        function getLineBoundingBox(p1, p2) {
            const margin = state.lineWidth / 2;
            const x = Math.min(p1.x, p2.x) - margin;
            const y = Math.min(p1.y, p2.y) - margin;
            const width = Math.abs(p1.x - p2.x) + 2 * margin;
            const height = Math.abs(p1.y - p2.y) + 2 * margin;
            return { x, y, width, height };
        }

        // Rectangle
        function getRect(p1, p2) {
            return {
                x: Math.min(p1.x, p2.x),
                y: Math.min(p1.y, p2.y),
                width: Math.abs(p1.x - p2.x),
                height: Math.abs(p1.y - p2.y)
            };
        }
        function drawRectangle(p1, p2, targetCtx = ctx) {
            const rect = getRect(p1, p2);
            targetCtx.lineWidth = state.lineWidth / (targetCtx === ctx ? state.zoom : 1);
            targetCtx.strokeStyle = state.strokeColor;
            targetCtx.fillStyle = state.fillColor;
            targetCtx.beginPath();
            targetCtx.rect(rect.x, rect.y, rect.width, rect.height);
            targetCtx.fill();
            targetCtx.stroke();
        }

        // Circle/Ellipse
        function drawCircle(p1, p2, targetCtx = ctx) {
            const rect = getRect(p1, p2);
            const kappa = .5522848;
            const ox = (rect.width / 2) * kappa;
            const oy = (rect.height / 2) * kappa;
            const xe = rect.x + rect.width;
            const ye = rect.y + rect.height;
            const xm = rect.x + rect.width / 2;
            const ym = rect.y + rect.height / 2;
            
            targetCtx.lineWidth = state.lineWidth / (targetCtx === ctx ? state.zoom : 1);
            targetCtx.strokeStyle = state.strokeColor;
            targetCtx.fillStyle = state.fillColor;
            
            targetCtx.beginPath();
            targetCtx.moveTo(rect.x, ym);
            targetCtx.bezierCurveTo(rect.x, ym - oy, xm - ox, rect.y, xm, rect.y);
            targetCtx.bezierCurveTo(xm + ox, rect.y, xe, ym - oy, xe, ym);
            targetCtx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            targetCtx.bezierCurveTo(xm - ox, ye, rect.x, ym + oy, rect.x, ym);
            targetCtx.closePath();
            targetCtx.fill();
            targetCtx.stroke();
        }

        // Polygon
        function handlePolygonClick() {
            state.tempPoints.push(state.startDrawPoint);
            // Redraw with preview lines
            ctx.putImageData(canvasSnapshot, 0, 0);
            applyTransform();
            ctx.lineWidth = state.lineWidth / state.zoom;
            ctx.strokeStyle = state.strokeColor;
            ctx.beginPath();
            ctx.moveTo(state.tempPoints[0].x, state.tempPoints[0].y);
            for (let i = 1; i < state.tempPoints.length; i++) {
                ctx.lineTo(state.tempPoints[i].x, state.tempPoints[i].y);
            }
            ctx.stroke();
            // Preview line to cursor
            if (state.tempPoints.length > 0) {
                ctx.setLineDash([5, 5]);
                ctx.lineTo(state.startDrawPoint.x, state.startDrawPoint.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        function finalizePolygon(e) {
            if (state.currentTool !== 'polygon' || state.tempPoints.length < 2) return;
            const points = state.tempPoints;
            state.tempPoints = [];

            // Find bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            const margin = state.lineWidth / 2;
            const rect = { x: minX - margin, y: minY - margin, width: (maxX - minX) + 2*margin, height: (maxY - minY) + 2*margin };

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = rect.width * state.zoom;
            tempCanvas.height = rect.height * state.zoom;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.scale(state.zoom, state.zoom);
            tempCtx.translate(-rect.x, -rect.y);

            tempCtx.fillStyle = state.fillColor;
            tempCtx.strokeStyle = state.strokeColor;
            tempCtx.lineWidth = state.lineWidth;
            tempCtx.beginPath();
            tempCtx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                tempCtx.lineTo(points[i].x, points[i].y);
            }
            tempCtx.closePath();
            tempCtx.fill();
            tempCtx.stroke();

            const asset = {
                img: new Image(),
                x: rect.x, y: rect.y,
                width: rect.width, height: rect.height
            };
            asset.img.src = tempCanvas.toDataURL();
            asset.img.onload = () => {
                state.assets.push(asset);
                redraw();
            };
        }
        
        // Arc
        function handleArcClick() {
            state.tempPoints.push(state.startDrawPoint);
            if (state.tempPoints.length === 3) {
                 finalizeArc();
            }
        }
        
        function finalizeArc() {
            const [p1, p2, cp] = state.tempPoints;
            state.tempPoints = [];

            // Bounding box for arc
            let minX = Math.min(p1.x, p2.x, cp.x), minY = Math.min(p1.y, p2.y, cp.y);
            let maxX = Math.max(p1.x, p2.x, cp.x), maxY = Math.max(p1.y, p2.y, cp.y);
            const margin = state.lineWidth / 2;
            const rect = { x: minX - margin, y: minY - margin, width: (maxX - minX) + 2*margin, height: (maxY - minY) + 2*margin };

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = rect.width * state.zoom;
            tempCanvas.height = rect.height * state.zoom;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.scale(state.zoom, state.zoom);
            tempCtx.translate(-rect.x, -rect.y);

            tempCtx.strokeStyle = state.strokeColor;
            tempCtx.lineWidth = state.lineWidth;
            tempCtx.beginPath();
            tempCtx.moveTo(p1.x, p1.y);
            tempCtx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y);
            tempCtx.stroke();
            
            const asset = {
                img: new Image(),
                x: rect.x, y: rect.y,
                width: rect.width, height: rect.height
            };
            asset.img.src = tempCanvas.toDataURL();
            asset.img.onload = () => {
                state.assets.push(asset);
                redraw();
            };
        }


        // --- Asset Management ---
        function handleFileDrop(e) {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'image/png') {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const worldPos = screenToWorld(getMousePos(e));
                        const asset = {
                            img,
                            x: worldPos.x - img.width / 2,
                            y: worldPos.y - img.height / 2,
                            width: img.width,
                            height: img.height
                        };
                        state.assets.push(asset);
                        redraw();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function getAssetUnderCursor(worldPos) {
            // Iterate backwards to select topmost asset
            for (let i = state.assets.length - 1; i >= 0; i--) {
                const asset = state.assets[i];
                if (worldPos.x >= asset.x && worldPos.x <= asset.x + asset.width &&
                    worldPos.y >= asset.y && worldPos.y <= asset.y + asset.height) {
                    return asset;
                }
            }
            return null;
        }

        // --- Selection & Transformation ---
        function handleSelectMouseDown(mousePos) {
            const worldPos = screenToWorld(mousePos);
            
            // Check if clicking a resize handle
            if (state.selectedAsset) {
                const handle = getHandleUnderCursor(mousePos, state.selectedAsset);
                if (handle) {
                    state.isTransforming = true;
                    state.transformHandle = handle.type;
                    return;
                }
            }
            
            const asset = getAssetUnderCursor(worldPos);
            state.selectedAsset = asset;

            if (asset) {
                state.isTransforming = true;
                state.transformHandle = 'move';
            } else {
                // Start drawing marquee
                state.selectionRect = { x: worldPos.x, y: worldPos.y, width: 0, height: 0 };
            }
            redraw();
        }
        
        function drawMarqueePreview(worldPos) {
             if (!state.selectionRect) return;
             state.selectionRect.width = worldPos.x - state.selectionRect.x;
             state.selectionRect.height = worldPos.y - state.selectionRect.y;
             redraw();
        }

        function getHandlePositions(asset) {
            const { x, y, width, height } = asset;
            const hw = width / 2, hh = height / 2;
            return {
                tl: { x: x, y: y },
                tm: { x: x + hw, y: y },
                tr: { x: x + width, y: y },
                ml: { x: x, y: y + hh },
                mr: { x: x + width, y: y + hh },
                bl: { x: x, y: y + height },
                bm: { x: x + hw, y: y + height },
                br: { x: x + width, y: y + height },
            };
        }

        function drawSelectionHandles(asset) {
            const handles = getHandlePositions(asset);
            ctx.save();
            ctx.strokeStyle = '#61afef';
            ctx.lineWidth = 1 / state.zoom;
            ctx.strokeRect(asset.x, asset.y, asset.width, asset.height);

            const handleSize = 8 / state.zoom;
            ctx.fillStyle = '#fff';
            for (const key in handles) {
                const pos = handles[key];
                ctx.fillRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
                ctx.strokeRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
            }
            ctx.restore();
        }
        
        function getHandleUnderCursor(mousePos, asset) {
            const handles = getHandlePositions(asset);
            const handleSize = 8 / state.zoom;
            for (const type in handles) {
                const screenPos = worldToScreen(handles[type]);
                if (Math.abs(mousePos.x - screenPos.x) < handleSize && Math.abs(mousePos.y - screenPos.y) < handleSize) {
                    let cursor = 'default';
                    if (type === 'tl' || type === 'br') cursor = 'nwse-resize';
                    if (type === 'tr' || type === 'bl') cursor = 'nesw-resize';
                    if (type === 'tm' || type === 'bm') cursor = 'ns-resize';
                    if (type === 'ml' || type === 'mr') cursor = 'ew-resize';
                    return { type, cursor };
                }
            }
            return null;
        }
        
        function handleAssetTransform(worldPos) {
            const asset = state.selectedAsset;
            const dx = worldPos.x - state.startDrawPoint.x;
            const dy = worldPos.y - state.startDrawPoint.y;

            const handle = state.transformHandle;
            const startAsset = { ...asset, ...state.startDrawPoint };
            
            if (handle === 'move') {
                asset.x += dx;
                asset.y += dy;
            } else {
                if (handle.includes('l')) { asset.width -= dx; asset.x += dx; }
                if (handle.includes('r')) { asset.width += dx; }
                if (handle.includes('t')) { asset.height -= dy; asset.y += dy; }
                if (handle.includes('b')) { asset.height += dy; }
            }
            
            state.startDrawPoint = worldPos;
        }

        // --- File & Clipboard ---
        function exportImage() {
            const bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            if (state.assets.length === 0) return alert('Canvas is empty!');

            state.assets.forEach(a => {
                bounds.minX = Math.min(bounds.minX, a.x);
                bounds.minY = Math.min(bounds.minY, a.y);
                bounds.maxX = Math.max(bounds.maxX, a.x + a.width);
                bounds.maxY = Math.max(bounds.maxY, a.y + a.height);
            });

            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = width;
            exportCanvas.height = height;
            const exportCtx = exportCanvas.getContext('2d');
            
            exportCtx.translate(-bounds.minX, -bounds.minY);
            
            state.assets.forEach(a => {
                exportCtx.drawImage(a.img, a.x, a.y, a.width, a.height);
            });

            const link = document.createElement('a');
            link.download = 'map-export.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        async function copySelection() {
            if (state.currentTool !== 'select') return;
            
            let rect;
            if (state.selectedAsset) {
                rect = state.selectedAsset;
            } else if (state.selectionRect) {
                // Normalize marquee rectangle
                const r = state.selectionRect;
                rect = {
                    x: r.width < 0 ? r.x + r.width : r.x,
                    y: r.height < 0 ? r.y + r.height : r.y,
                    width: Math.abs(r.width),
                    height: Math.abs(r.height),
                };
            } else {
                return; // Nothing to copy
            }
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = rect.width;
            tempCanvas.height = rect.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.translate(-rect.x, -rect.y);
            
            // Draw only assets that intersect with the selection
            state.assets.forEach(asset => {
                if (rect.x < asset.x + asset.width && rect.x + rect.width > asset.x &&
                    rect.y < asset.y + asset.height && rect.y + rect.height > asset.y)
                {
                    tempCtx.drawImage(asset.img, asset.x, asset.y, asset.width, asset.height);
                }
            });
            
            tempCanvas.toBlob(async (blob) => {
                try {
                    await navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]);
                    console.log('Selection copied to clipboard.');
                } catch(err) {
                    console.error('Failed to copy to clipboard:', err);
                }
            });
        }
        
        async function pasteFromClipboard() {
            try {
                const clipboardItems = await navigator.clipboard.read();
                for (const item of clipboardItems) {
                    if (item.types.includes('image/png')) {
                        const blob = await item.getType('image/png');
                        const img = new Image();
                        img.src = URL.createObjectURL(blob);
                        img.onload = () => {
                            const center = screenToWorld({x: canvas.width/2, y: canvas.height/2});
                             const asset = {
                                img,
                                x: center.x - img.width / 2,
                                y: center.y - img.height / 2,
                                width: img.width,
                                height: img.height
                            };
                            state.assets.push(asset);
                            setTool('select');
                            state.selectedAsset = asset;
                            redraw();
                        };
                        return; // Paste only the first image
                    }
                }
            } catch (err) {
                console.error('Failed to paste from clipboard:', err);
            }
        }
        
        function updateStatusBar(worldPos = {x:0, y:0}) {
            statusBar.textContent = `Zoom: ${Math.round(state.zoom * 100)}% | X: ${Math.round(worldPos.x)}, Y: ${Math.round(worldPos.y)} | Tool: ${state.currentTool}`;
        }

        // --- Init & Event Listeners ---
        function init() {
            resizeCanvas();
            
            // General Canvas Listeners
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', () => {
                 if (state.isDrawing) onMouseUp();
                 state.isDrawing = false;
                 state.isPanning = false;
            });
            canvas.addEventListener('wheel', onWheel, { passive: false });
            canvas.addEventListener('dblclick', finalizePolygon);
            
            // Drag and Drop
            canvasContainer.addEventListener('dragover', e => e.preventDefault());
            canvasContainer.addEventListener('drop', handleFileDrop);

            // Toolbar Listeners
            document.querySelectorAll('.tool').forEach(btn => {
                btn.addEventListener('click', () => setTool(btn.dataset.tool));
            });
            
            document.querySelectorAll('.special-tool').forEach(btn => {
                btn.addEventListener('click', () => {
                    const toolType = btn.dataset.tool;
                    setTool('freestyle');
                    switch(toolType) {
                        case 'road':
                            state.lineWidth = 20;
                            state.strokeColor = '#666666';
                            break;
                        case 'piping':
                            state.lineWidth = 8;
                            state.strokeColor = '#a0a0a0';
                            break;
                        case 'electrical':
                            state.lineWidth = 3;
                            state.strokeColor = '#ffcc00';
                            break;
                        case 'plumbing':
                            state.lineWidth = 6;
                            state.strokeColor = '#3399ff';
                            break;
                    }
                    strokeColorInput.value = state.strokeColor;
                    lineWidthInput.value = state.lineWidth;
                });
            });

            strokeColorInput.addEventListener('input', (e) => state.strokeColor = e.target.value);
            fillColorInput.addEventListener('input', (e) => state.fillColor = e.target.value);
            lineWidthInput.addEventListener('input', (e) => state.lineWidth = e.target.value);
            eraserSizeInput.addEventListener('input', (e) => state.eraserSize = e.target.value);
            exportBtn.addEventListener('click', exportImage);

            // Global Listeners
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', e => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                    copySelection();
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                    pasteFromClipboard();
                }
            });

            setTool('select'); // Start with select tool active
        }

        init();
    })();
    </script>
</body>
</html>
